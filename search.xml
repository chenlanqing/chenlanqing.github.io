<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker网络配置</title>
    <url>/2025/02/09/Docker%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A/</url>
    <content><![CDATA[<h2 id="1、Mac连通虚拟机中的Docker网络"><a href="#1、Mac连通虚拟机中的Docker网络" class="headerlink" title="1、Mac连通虚拟机中的Docker网络"></a>1、Mac连通虚拟机中的Docker网络</h2><p>假设有Mac、虚拟机、Docker中的IP地址如下：</p>
<table>
<thead>
<tr>
<th>机器</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>Mac IP地址:</td>
<td>192.168.31.196</td>
</tr>
<tr>
<td>虚拟机IP:</td>
<td>192.168.31.221</td>
</tr>
<tr>
<td>Docker网络IP地址</td>
<td>172.19.0.3</td>
</tr>
</tbody></table>
<p>当前 Mac 可以ping通 虚拟机，虚拟机可以ping同虚拟机中的Docker网络，但是Mac无法ping同虚拟机中的Docker</p>
<p>那么可以通过添加路由表到Mac中：</p>
<pre><code>sudo route -n add -net 172.19.0.0 -netmask 255.255.255.0 192.168.31.221</code></pre>
<p>添加网络路由，172.19.0.0 mask 255.255.255.0 都由 192.168.31.221 来帮忙转发</p>
<p>那么路由表信息如下：（查看路由表： <code>netstat -nr</code>）</p>
<pre><code>Internet:
Destination        Gateway            Flags        Refs      Use   Netif Expire
172.19/24          192.168.31.221     UGSc            0        3     en0</code></pre>
<p>如果需要删除路由表，执行如下命令：</p>
<pre><code>sudo route delete 172.19/24</code></pre>
<h2 id="2、Windows连接到虚拟机的docker网络"><a href="#2、Windows连接到虚拟机的docker网络" class="headerlink" title="2、Windows连接到虚拟机的docker网络"></a>2、Windows连接到虚拟机的docker网络</h2><p>假设有Windows、虚拟机、Docker中的IP地址如下：</p>
<table>
<thead>
<tr>
<th>机器</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>WindowsIP地址:</td>
<td>192.168.31.196</td>
</tr>
<tr>
<td>虚拟机IP:</td>
<td>192.168.31.221</td>
</tr>
<tr>
<td>Docker网络IP地址</td>
<td>172.19.0.3</td>
</tr>
</tbody></table>
<p>在windows中添加路由地址：</p>
<pre><code>ROUTE -p add 172.19.0.0 mask 255.255.255.0 192.168.31.221</code></pre>
<p>添加网络路由，172.19.0.0 mask 255.255.255.0 都由 192.168.31.221 来帮忙转发</p>
<p>删除路由：</p>
<pre><code>route delete 172.19.0.0 mask 255.255.255.0 192.168.31.221</code></pre>
<p><strong>注意点：需要关闭虚拟机的防火墙</strong></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Gson自定义映射</title>
    <url>/2025/02/09/Gson%E8%87%AA%E5%AF%B9%E5%BA%94%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>日常业务开发中我们有时候需要对json字符串转换成实体时做一些自对应的映射，今天我们使用Gson的TypeAdapter来实现</p>
<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>最近在做考勤系统的时候，有一个页面展示需要根据每天考勤类型显示不同的显示符号，比如：</p>
<pre><code>事假：△
调休：*
年假：□
正常：V
早退：#
加班：☆</code></pre>
<p>原始数据格式：</p>
<pre><code class="line-numbers language-json">&#123;
  &quot;01&quot;: &quot;3&quot;,
  &quot;02&quot;: &quot;3&quot;,
  &quot;06&quot;: &quot;4&quot;,
  &quot;07&quot;: &quot;3&quot;,
  &quot;08&quot;: &quot;3&quot;,
  &quot;11&quot;: &quot;0&quot;,
  &quot;12&quot;: &quot;3&quot;,
  &quot;13&quot;: &quot;3&quot;,
  &quot;14&quot;: &quot;3&quot;,
  &quot;15&quot;: &quot;3&quot;,
  &quot;18&quot;: &quot;3&quot;,
  &quot;19&quot;: &quot;3&quot;,
  &quot;20&quot;: &quot;3&quot;,
  &quot;21&quot;: &quot;4&quot;,
  &quot;22&quot;: &quot;0&quot;,
  &quot;24&quot;: &quot;0&quot;,
  &quot;25&quot;: &quot;3&quot;,
  &quot;26&quot;: &quot;4&quot;,
  &quot;27&quot;: &quot;4&quot;,
  &quot;28&quot;: &quot;3&quot;,
  &quot;29&quot;: &quot;3&quot;,
  &quot;30&quot;: &quot;1&quot;,
  &quot;31&quot;: &quot;7&quot;
&#125;</code></pre>
<p>对应的实体类：</p>
<pre><code class="line-numbers language-java">public class CheckReport &#123;
    private String day_1;
    private String day_2;
    private String day_3;
    private String day_4;
    private String day_5;
    private String day_6;
    private String day_7;
    private String day_8;
    private String day_9;
    private String day_10;
    private String day_11;
    private String day_12;
    private String day_13;
    private String day_14;
    private String day_15;
    private String day_16;
    private String day_17;
    private String day_18;
    private String day_19;
    private String day_20;
    private String day_21;
    private String day_22;
    private String day_23;
    private String day_24;
    private String day_25;
    private String day_26;
    private String day_27;
    private String day_28;
    private String day_29;
    private String day_30;
    private String day_31;
&#125;</code></pre>
<p>我们需要将json格式转换如下数据格式：</p>
<pre><code class="line-numbers language-json">&#123;
  &quot;day_1&quot;: &quot;正常出勤&quot;,
  &quot;day_2&quot;: &quot;正常出勤&quot;,
  &quot;day_6&quot;: &quot;早退&quot;,
  &quot;day_7&quot;: &quot;正常出勤&quot;,
  &quot;day_8&quot;: &quot;正常出勤&quot;,
  &quot;day_11&quot;: &quot;事假&quot;,
  &quot;day_12&quot;: &quot;正常出勤&quot;,
  &quot;day_13&quot;: &quot;正常出勤&quot;,
  &quot;day_14&quot;: &quot;正常出勤&quot;,
  &quot;day_15&quot;: &quot;正常出勤&quot;,
  &quot;day_18&quot;: &quot;正常出勤&quot;,
  &quot;day_19&quot;: &quot;正常出勤&quot;,
  &quot;day_20&quot;: &quot;正常出勤&quot;,
  &quot;day_21&quot;: &quot;早退&quot;,
  &quot;day_22&quot;: &quot;事假&quot;,
  &quot;day_24&quot;: &quot;事假&quot;,
  &quot;day_25&quot;: &quot;正常出勤&quot;,
  &quot;day_26&quot;: &quot;早退&quot;,
  &quot;day_27&quot;: &quot;早退&quot;,
  &quot;day_28&quot;: &quot;正常出勤&quot;,
  &quot;day_29&quot;: &quot;正常出勤&quot;,
  &quot;day_30&quot;: &quot;调休&quot;,
  &quot;day_31&quot;: &quot;加班&quot;
&#125;</code></pre>
<p>那么传统的方式就无法实现了</p>
<h2 id="2、实现步骤"><a href="#2、实现步骤" class="headerlink" title="2、实现步骤"></a>2、实现步骤</h2><h3 id="2-1、引入依赖"><a href="#2-1、引入依赖" class="headerlink" title="2.1、引入依赖"></a>2.1、引入依赖</h3><p>这里使用Gson的依赖：</p>
<pre><code class="line-numbers language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
    &lt;artifactId&gt;gson&lt;/artifactId&gt;
    &lt;version&gt;$&#123;latest.version&#125;&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h3 id="2-2、自定义TypeAdapter"><a href="#2-2、自定义TypeAdapter" class="headerlink" title="2.2、自定义TypeAdapter"></a>2.2、自定义TypeAdapter</h3><pre><code class="line-numbers language-java">public class CheckResultTypeAdapter extends TypeAdapter&lt;CheckReport&gt; &#123;
    // 这个是对象转成json字符串的时候使用的写出的方法
    @Override
    public void write(JsonWriter out, CheckReport value) throws IOException &#123;
        out.beginObject();
        writeData(out, value);
        out.endObject();
    &#125;

    private void writeData(JsonWriter out, CheckReport report) &#123;
        final Field[] fields = report.getClass().getDeclaredFields();
        for (Field field : fields) &#123;
            try &#123;
                field.setAccessible(true);
                String filedName = field.getName();
                Object resultVal = field.get(report);
                if (resultVal == null) &#123;
                    continue;
                &#125;
                String value = String.valueOf(resultVal);
                CheckResultEnum resultEnum = CheckResultEnum.fromDesc(value);
                value = String.valueOf(resultEnum.getCode());
                if (filedName.contains(&quot;day_&quot;)) &#123;
                    filedName = filedName.replace(&quot;day_&quot;, &quot;&quot;);
                    filedName = String.format(&quot;%02d&quot;, Integer.parseInt(filedName));
                &#125;
                out.name(filedName).value(value);
            &#125; catch (Exception e) &#123;
                //ignore
            &#125;
        &#125;
    &#125;
    // 从字符串中读取数据将其转换成对象
    @Override
    public CheckReport read(JsonReader reader) throws IOException &#123;
        reader.beginObject();
        String fieldName = &quot;&quot;;
        CheckReport detail = new CheckReport();
        while (reader.hasNext()) &#123;
            JsonToken token = reader.peek();
            if (token.equals(JsonToken.NAME)) &#123;
                fieldName = reader.nextName();
            &#125;
            token = reader.peek();
            setData(detail, fieldName, reader.nextString());
        &#125;
        reader.endObject();
        return detail;
    &#125;

    private void setData(CheckReport detail, String fieldName, String nextString) &#123;
        try &#123;
            // 通过反射的方式将数据赋值
            Class&lt;?&gt; clazz = detail.getClass();
            String actualName = &quot;day_&quot; + Integer.parseInt(fieldName);
            Field field = clazz.getDeclaredField(actualName);
            field.setAccessible(true);
            StringBuilder sb = new StringBuilder();
            if (nextString.contains(&quot;,&quot;)) &#123;
                String[] split = nextString.split(&quot;,&quot;);
                for (String data : split) &#123;
                    CheckResultEnum resultTypeEnum = CheckResultEnum.fromCode(Integer.parseInt(data));
                    if (resultTypeEnum != null) &#123;
                        sb.append(resultTypeEnum.getDesc());
                    &#125;
                &#125;
            &#125; else &#123;
                CheckResultEnum resultTypeEnum = CheckResultEnum.fromCode(Integer.parseInt(nextString));
                if (resultTypeEnum != null) &#123;
                    sb.append(resultTypeEnum.getDesc());
                &#125;
            &#125;
            field.set(detail, sb.toString());
        &#125; catch (Exception e) &#123;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="2-3、使用"><a href="#2-3、使用" class="headerlink" title="2.3、使用"></a>2.3、使用</h3><pre><code class="line-numbers language-java">public static void main(String[] args) &#123;
    GsonBuilder builder = new GsonBuilder();
    // 通过GsonBuilder将自定义的adapter注册进去
    builder.registerTypeAdapter(CheckReport.class, new CheckResultTypeAdapter());
    builder.setPrettyPrinting();
    Gson gson = builder.create();
    String json = &quot;&#123;\n&quot;
            + &quot;    \&quot;01\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;02\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;06\&quot;:\&quot;4\&quot;,\n&quot;
            + &quot;    \&quot;07\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;08\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;11\&quot;:\&quot;0\&quot;,\n&quot;
            + &quot;    \&quot;12\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;13\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;14\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;15\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;18\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;19\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;20\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;21\&quot;:\&quot;4\&quot;,\n&quot;
            + &quot;    \&quot;22\&quot;:\&quot;0\&quot;,\n&quot;
            + &quot;    \&quot;24\&quot;:\&quot;0\&quot;,\n&quot;
            + &quot;    \&quot;25\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;26\&quot;:\&quot;4\&quot;,\n&quot;
            + &quot;    \&quot;27\&quot;:\&quot;4\&quot;,\n&quot;
            + &quot;    \&quot;28\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;29\&quot;:\&quot;3\&quot;,\n&quot;
            + &quot;    \&quot;30\&quot;:\&quot;1\&quot;,\n&quot;
            + &quot;    \&quot;31\&quot;:\&quot;7\&quot;\n&quot;
            + &quot;&#125;&quot;;
    final CheckReport report = gson.fromJson(json, CheckReport.class);
    System.out.println(JSON.toJSONString(report));
    System.out.println(gson.toJson(report));
&#125;</code></pre>
<p>输出结果：</p>
<pre><code class="line-numbers language-java">// 输出的是正常对象转换成json
&#123;&quot;day_1&quot;:&quot;正常出勤&quot;,&quot;day_11&quot;:&quot;事假&quot;,&quot;day_12&quot;:&quot;正常出勤&quot;,&quot;day_13&quot;:&quot;正常出勤&quot;,&quot;day_14&quot;:&quot;正常出勤&quot;,&quot;day_15&quot;:&quot;正常出勤&quot;,&quot;day_18&quot;:&quot;正常出勤&quot;,&quot;day_19&quot;:&quot;正常出勤&quot;,&quot;day_2&quot;:&quot;正常出勤&quot;,&quot;day_20&quot;:&quot;正常出勤&quot;,&quot;day_21&quot;:&quot;早退&quot;,&quot;day_22&quot;:&quot;事假&quot;,&quot;day_24&quot;:&quot;事假&quot;,&quot;day_25&quot;:&quot;正常出勤&quot;,&quot;day_26&quot;:&quot;早退&quot;,&quot;day_27&quot;:&quot;早退&quot;,&quot;day_28&quot;:&quot;正常出勤&quot;,&quot;day_29&quot;:&quot;正常出勤&quot;,&quot;day_30&quot;:&quot;调休&quot;,&quot;day_31&quot;:&quot;加班&quot;,&quot;day_6&quot;:&quot;早退&quot;,&quot;day_7&quot;:&quot;正常出勤&quot;,&quot;day_8&quot;:&quot;正常出勤&quot;&#125;
// 通过Gson将对象还原成了原始json字符串
&#123;
  &quot;01&quot;: &quot;3&quot;,
  &quot;02&quot;: &quot;3&quot;,
  &quot;06&quot;: &quot;4&quot;,
  &quot;07&quot;: &quot;3&quot;,
  &quot;08&quot;: &quot;3&quot;,
  &quot;11&quot;: &quot;0&quot;,
  &quot;12&quot;: &quot;3&quot;,
  &quot;13&quot;: &quot;3&quot;,
  &quot;14&quot;: &quot;3&quot;,
  &quot;15&quot;: &quot;3&quot;,
  &quot;18&quot;: &quot;3&quot;,
  &quot;19&quot;: &quot;3&quot;,
  &quot;20&quot;: &quot;3&quot;,
  &quot;21&quot;: &quot;4&quot;,
  &quot;22&quot;: &quot;0&quot;,
  &quot;24&quot;: &quot;0&quot;,
  &quot;25&quot;: &quot;3&quot;,
  &quot;26&quot;: &quot;4&quot;,
  &quot;27&quot;: &quot;4&quot;,
  &quot;28&quot;: &quot;3&quot;,
  &quot;29&quot;: &quot;3&quot;,
  &quot;30&quot;: &quot;1&quot;,
  &quot;31&quot;: &quot;7&quot;
&#125;</code></pre>
]]></content>
      <categories>
        <category>Gson</category>
      </categories>
      <tags>
        <tag>Gson</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用开发配置</title>
    <url>/2025/02/09/IDEA%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、常见配置"><a href="#一、常见配置" class="headerlink" title="一、常见配置"></a>一、常见配置</h1><h2 id="1、添加类签名及版本信息"><a href="#1、添加类签名及版本信息" class="headerlink" title="1、添加类签名及版本信息"></a>1、添加类签名及版本信息</h2><p>Settings -&gt; Editor -&gt; File and Code Templates</p>
<p><img src="/images/IDEA-Template.png"></p>
<p>上面的<code>FileHeader.java</code>可以定义为通用的文件注释，还可以增加版权信息等</p>
<p><img src="/images/IDEA-Template2.png"></p>
<p>将上面定义好的的FileHeader引入到到include里的Class里面，使用parse来解析：</p>
<pre><code class="line-numbers language-java">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end
#parse(&quot;File Header.java&quot;)
public class $&#123;NAME&#125; &#123;
&#125;</code></pre>
<p>同样的，可以再include里面添加模板文件，比如添加了一个NettyServerClass</p>
<p><img src="/images/IDEA-Template3.png"></p>
<p>在new里面可以选择NettyServerClass作为Java类文件模板：</p>
<p><img src="/images/IDEA-Template4.png"></p>
<h2 id="2、Maven"><a href="#2、Maven" class="headerlink" title="2、Maven"></a>2、Maven</h2><p>Settings -&gt; Build, Execution, Deployment -&gt; Build Tools -&gt; Maven</p>
<p><img src="/images/IDEA-Maven.png"></p>
<h2 id="3、方法分割线以及字符缩进"><a href="#3、方法分割线以及字符缩进" class="headerlink" title="3、方法分割线以及字符缩进"></a>3、方法分割线以及字符缩进</h2><p><img src="/images/IDEA-%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%88%86%E5%89%B2%E7%BA%BF.png"></p>
<h2 id="4、修改idea默认配置路径"><a href="#4、修改idea默认配置路径" class="headerlink" title="4、修改idea默认配置路径"></a>4、修改idea默认配置路径</h2><ul>
<li><a href="https://intellij-support.jetbrains.com/hc/en-us/articles/207240985-Changing-IDE-default-directories-used-for-config-plugins-and-caches-storage">Changing IDE default directories used for config, plugins, and caches storage</a></li>
</ul>
<p>以Windows为例，IDEA默认配置路径基本都是在C盘目录下的：</p>
<pre><code class="line-numbers language-java">// idea的相关配置、插件目录
C:&#123;user.home&#125;/AppData/Roaming/JetBrains/IdeaIC2024.2
// idea的相关系统配置目录：缓存、日志等
C:&#123;user.home&#125;/AppData/Local/JetBrains/IdeaIC2024.2</code></pre>
<p>修改 <code>IDE_HOME\bin\idea.properties</code> 文件中的注释更改默认值，确保取消注释定义这些属性的行：</p>
<pre><code class="line-numbers language-properties">idea.config.path=
idea.system.path=
idea.plugins.path=
idea.log.path=</code></pre>
<p>修改对应的配置为：</p>
<pre><code class="line-numbers language-properties">## 配置的目录
idea.config.path=D:/cache/idea/trunk-config
## 配置缓存的目录：index
idea.system.path=D:/cache/idea/trunk-system 
## 配置插件的目录，一般是在 config目录里面的
idea.plugins.path=D:/cache/idea/trunk-config/plugins
## 配置日志目录
idea.log.path=D:/cache/idea/trunk-system/trunk-log</code></pre>
<p><strong>如何将默认配置的数据移动到新目录中：</strong></p>
<ul>
<li>将<code>C:&#123;user.home&#125;/AppData/Roaming/JetBrains/IdeaIC2024.2</code> 移动到新的目录：<code>idea.config.path</code></li>
<li><code>C:&#123;user.home&#125;/AppData/Local/JetBrains/IdeaIC2024.2</code> 目录下的数据不需要移动；</li>
</ul>
<p>做完之后即可使用原有的目录配置数据</p>
<h1 id="二、常用插件"><a href="#二、常用插件" class="headerlink" title="二、常用插件"></a>二、常用插件</h1><ul>
<li>阿里巴巴代码插件：Alibaba Java Coding Guidelines、Alibaba Cloud Toolkit</li>
<li>背景图片插件：Background Image Plus</li>
<li>格式化xml：Eclipse Code Fromatter</li>
<li>Mybtis插件：Free Mybatis Plugin、Mybatis plugin、Mybatis xml validator、MyBatisCodeHelperPro</li>
<li>Lombok</li>
<li>主题插件：Material Theme UI、Atom Material Icons</li>
<li>代码扫描插件：SonarLint</li>
<li>CodeGlance：可以显示代码的缩略图</li>
<li>GsonFormat：可以将一个json字符串转成对象</li>
<li>Key Promoter X</li>
<li>Maven Helper</li>
<li>RestfulToolkit</li>
<li>RestfulTool：可以根据 URL 直接跳转到对应的方法，也可以通过 controller 复制出来对应的 url</li>
<li>Statistic</li>
<li>VisualVM Launcher</li>
<li>ASM</li>
<li>mybatisX</li>
<li>Rainbow Brackets ：括号插件</li>
<li>GitToolBox：Git工具箱(增强)</li>
<li>Better Highlights：代码认知复杂度</li>
<li>Arthas</li>
<li>CheckStyle-IDEA</li>
<li>JRebel and XRebel</li>
<li>Continue 是一个适配 IntelliJ IDEA 的开源 AI 助手插件，旨在通过自然语言与代码的交互来提升开发效率。与 CodeGPT、GitHub Copilot 等类似，它基于大语言模型（如 OpenAI 、DeepSeek 或其他模型），为开发者提供实时代码生成、问题解决、单元测试生成等功能。</li>
<li>CodeGPT 是一款人工智能代码助手，是 GitHub Copilot、AI Assistant、Codiumate 和其他 JetBrains 插件的强大替代品，支持集成市面上常见的大模型</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Unsafe分析</title>
    <url>/2025/02/09/Java-Unsafe/</url>
    <content><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p>Unsafe是位于<code>sun.misc</code>包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重；</p>
<h2 id="1-1、基本介绍"><a href="#1-1、基本介绍" class="headerlink" title="1.1、基本介绍"></a>1.1、基本介绍</h2><p>如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常：</p>
<pre><code class="line-numbers language-java">public final class Unsafe &#123;
    private static final Unsafe theUnsafe;
    private Unsafe() &#123;
    &#125;
    @CallerSensitive
    public static Unsafe getUnsafe() &#123;
        Class var0 = Reflection.getCallerClass();
        // 仅在引导类加载器 BootstrapClassLoader 加载时才合法
        if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;
            throw new SecurityException(&quot;Unsafe&quot;);
        &#125; else &#123;
            return theUnsafe;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="1-2、如何使用"><a href="#1-2、如何使用" class="headerlink" title="1.2、如何使用"></a>1.2、如何使用</h2><h3 id="1-2-1、方式一：设置包路径"><a href="#1-2-1、方式一：设置包路径" class="headerlink" title="1.2.1、方式一：设置包路径"></a>1.2.1、方式一：设置包路径</h3><p>从getUnsafe方法的使用限制条件出发，通过Java命令行命令<code>-Xbootclasspath/a</code>把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例：<code>java -Xbootclasspath/a: $&#123;path&#125;   // 其中path为调用Unsafe相关方法的类所在jar包路径</code></p>
<h3 id="1-2-2、方式二：反射"><a href="#1-2-2、方式二：反射" class="headerlink" title="1.2.2、方式二：反射"></a>1.2.2、方式二：反射</h3><p>通过反射获取单例对象theUnsafe</p>
<pre><code class="line-numbers language-java">public static void main(String args[]) throws Throwable &#123;
    Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
    f.setAccessible(true);
    Unsafe unsafe = (Unsafe) f.get(null);
&#125;</code></pre>
<p><strong>注意：</strong>Unsafe在JDK11无法直接使用：sun.misc.Unsafe，需要在 源码包中新建文件： module-info.java，该文件内容如下：</p>
<pre><code class="line-numbers language-java">module unsafe&#123;
    requires jdk.unsupported;
&#125;
// 最终目录结构是：
├── src
│   ├── main
│   │   ├── java
│   │   │   ├── com
│   │   │   │   └── blue
│   │   │   │       └── fish
│   │   │   │           └── example
│   │   │   │               ├── ExampleApplication.java
│   │   │   └── module-info.java</code></pre>
<h1 id="2、功能介绍"><a href="#2、功能介绍" class="headerlink" title="2、功能介绍"></a>2、功能介绍</h1><p><img src="/images/Unsafe-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D.png"></p>
<p>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类</p>
<h2 id="2-1、内存操作"><a href="#2-1、内存操作" class="headerlink" title="2.1、内存操作"></a>2.1、内存操作</h2><p>这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。</p>
<pre><code class="line-numbers language-java">//分配内存, 相当于C++的malloc函数
public native long allocateMemory(long bytes);
//扩充内存
public native long reallocateMemory(long address, long bytes);
//释放内存
public native void freeMemory(long address);
//在给定的内存块中设置值
public native void setMemory(Object o, long offset, long bytes, byte value);
//内存拷贝
public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等
public native Object getObject(Object o, long offset);
//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等
public native void putObject(Object o, long offset, Object x);
//获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）
public native byte getByte(long address);
//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）
public native void putByte(long address, byte x);</code></pre>
<p>通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法</p>
<p><strong>使用堆外内存的原因：</strong></p>
<ul>
<li>对垃圾回收停顿的改善：由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。</li>
<li>提升程序I/O操作的性能：通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
<p><strong>典型应用：</strong></p>
<p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。</p>
<p>下面是DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过<code>Unsafe.allocateMemory</code>分配内存、<code>Unsafe.setMemory</code>进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放：</p>
<pre><code class="line-numbers language-java">DirectByteBuffer(int cap) &#123;                   // package-private
    super(-1, 0, cap, cap);
    boolean pa = VM.isDirectMemoryPageAligned();
    int ps = Bits.pageSize();
    long size = Math.max(1L, (long)cap + (pa ? ps : 0));
    // 校验堆外内存释放有足够空间： -XX:MaxDirectMemorySize
    Bits.reserveMemory(size, cap);
    long base = 0;
    try &#123;
        // 分配内存，并返回基地址
        base = unsafe.allocateMemory(size);
    &#125; catch (OutOfMemoryError x) &#123;
        Bits.unreserveMemory(size, cap);
        throw x;
    &#125;
    // 内存初始化
    unsafe.setMemory(base, size, (byte) 0);
    if (pa &amp;&amp; (base % ps != 0)) &#123;
        // Round up to page boundary
        address = base + ps - (base &amp; (ps - 1));
    &#125; else &#123;
        address = base;
    &#125;
    // 跟踪DirectByteBuffer对象的垃圾回收，以实现堆外内存的释放；
    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
    att = null;
&#125;</code></pre>
<p><strong>那么如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？</strong></p>
<p>Cleaner继承自Java四大引用类型之一的虚引用PhantomReference（众所周知，无法通过虚引用获取与之关联的对象实例，且当对象仅被虚引用引用时，在任何发生GC的时候，其均可被回收），通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。如下图所示，当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作</p>
<p><img src="/images/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98GC-Cleaner%E8%BF%87%E7%A8%8B.png"></p>
<p>所以当DirectByteBuffer仅被Cleaner引用（即为虚引用）时，其可以在任意GC时段被回收。当DirectByteBuffer实例对象被回收时，在Reference-Handler线程操作中，会调用Cleaner的clean方法根据创建Cleaner时传入的Deallocator来进行堆外内存的释放</p>
<pre><code class="line-numbers language-java">public static void main(String[] args) throws InterruptedException &#123;
    ByteBuffer buffer = ByteBuffer.allocateDirect(1024*1024*512);
    ReferenceQueue&lt;ByteBuffer&gt; rq = new ReferenceQueue&lt;&gt;();
    PhantomReference reference =  ((DirectBuffer)buffer).cleaner();
    // ((DirectBuffer)buffer).cleaner().clean();
    buffer = null;
    System.gc();
    Thread.sleep(500);
&#125;</code></pre>
<p>回收过程：</p>
<p><img src="/images/DirectByteBuffer-Cleaner%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="2-2、CAS相关"><a href="#2-2、CAS相关" class="headerlink" title="2.2、CAS相关"></a>2.2、CAS相关</h2><pre><code class="line-numbers language-java">/**
  * @param o         包含要修改field的对象
  * @param offset    对象中某field的偏移量
  * @param expected  期望值
  * @param update    更新值
  * @return          true | false
  */
public final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);

public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);

public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);</code></pre>
<p>关于CAS，参考<a href="../Java%E5%9F%BA%E7%A1%80/Java%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B.md#2CAS">CAS</a></p>
<p>CAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。比如，AtomicInteger的实现中，静态字段valueOffset即为字段value的内存偏移地址，valueOffset的值在AtomicInteger初始化时，在静态代码块中通过Unsafe的objectFieldOffset方法获取。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作</p>
<h2 id="2-3、线程调度"><a href="#2-3、线程调度" class="headerlink" title="2.3、线程调度"></a>2.3、线程调度</h2><p>包括线程挂起、恢复、锁机制等方法</p>
<pre><code class="line-numbers language-java">//取消阻塞线程
public native void unpark(Object thread);
//阻塞线程
public native void park(boolean isAbsolute, long time);
//获得对象锁（可重入锁）
@Deprecated
public native void monitorEnter(Object o);
//释放对象锁
@Deprecated
public native void monitorExit(Object o);
//尝试获取对象锁
@Deprecated
public native boolean tryMonitorEnter(Object o);</code></pre>
<p>方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常；</p>
<p><strong>典型应用：</strong>Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现；</p>
<h2 id="2-4、Class相关"><a href="#2-4、Class相关" class="headerlink" title="2.4、Class相关"></a>2.4、Class相关</h2><p>此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。</p>
<pre><code class="line-numbers language-java">//获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的
public native long staticFieldOffset(Field f);
//获取一个静态类中给定字段的对象指针
public native Object staticFieldBase(Field f);
//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false。
public native boolean shouldBeInitialized(Class&lt;?&gt; c);
//检测给定的类是否已经初始化。通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。
public native void ensureClassInitialized(Class&lt;?&gt; c);
//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者
public native Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);
//定义一个匿名类
public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);</code></pre>
<p><strong>典型应用</strong></p>
<p>从Java 8开始，JDK使用<code>invokedynamic</code>及<code>VM Anonymous Class</code>结合来实现Java语言层面上的<a href="../Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#8.3Lambda%E5%8E%9F%E7%90%86">Lambda表达式</a></p>
<ul>
<li><code>invokedynamic</code>： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。</li>
<li><code>VM Anonymous Class</code>：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过<code>Unsafe.defineAnonymousClass方</code>法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而<code>VM Anonymous Class</code>相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。</li>
</ul>
<p>在Lambda表达式实现中，通过<code>invokedynamic</code>指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能</p>
<pre><code class="line-numbers language-java">public class Test &#123;
    public static void main(String[] args) &#123;
        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);
        consumer.accept(&quot;lambda&quot;);
    &#125;
&#125;</code></pre>
<p>上述反编译字节码：</p>
<pre><code class="line-numbers language-java">SourceFile: &quot;Test.java&quot;
InnerClasses:
  public static final #63= #62 of #66;    // Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles
BootstrapMethods:
  0: #32 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #33 (Ljava/lang/Object;)V
      #34 REF_invokeStatic com/blue/fish/example/bytecode/Test.lambda$main$0:(Ljava/lang/String;)V
      #35 (Ljava/lang/String;)V</code></pre>
<p>可以从中看到main方法的指令实现、invokedynamic指令调用的引导方法BootstrapMethods、及静态方法<code>lambda$main$0</code>（实现了Lambda表达式中字符串打印逻辑）等。在引导方法执行过程中，会通过Unsafe.defineAnonymousClass生成如下实现Consumer接口的匿名类。其中，accept方法通过调用Test类中的静态方法lambda$main$0来实现Lambda表达式中定义的逻辑</p>
<h2 id="2-5、对象操作"><a href="#2-5、对象操作" class="headerlink" title="2.5、对象操作"></a>2.5、对象操作</h2><p>此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法</p>
<pre><code class="line-numbers language-java">//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量
public native long objectFieldOffset(Field f);
//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等
public native Object getObject(Object o, long offset);
//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等
public native void putObject(Object o, long offset, Object x);
//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义
public native Object getObjectVolatile(Object o, long offset);
//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义
public native void putObjectVolatile(Object o, long offset, Object x);
//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效
public native void putOrderedObject(Object o, long offset, Object x);
//绕过构造方法、初始化代码来创建对象
public native Object allocateInstance(Class&lt;?&gt; cls) throws InstantiationException;</code></pre>
<p><strong>典型应用：</strong></p>
<ul>
<li>常规对象实例化方式：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li>
<li>非常规的实例化方式：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用；</li>
</ul>
<h2 id="2-6、数组相关"><a href="#2-6、数组相关" class="headerlink" title="2.6、数组相关"></a>2.6、数组相关</h2><p>与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置</p>
<pre><code class="line-numbers language-java">//返回数组中第一个元素的偏移地址
public native int arrayBaseOffset(Class&lt;?&gt; arrayClass);
//返回数组中一个元素占用的大小
public native int arrayIndexScale(Class&lt;?&gt; arrayClass);</code></pre>
<p>典型应用<br>这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用，如下图AtomicIntegerArray源码所示，通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位；</p>
<h2 id="2-7、内存屏障"><a href="#2-7、内存屏障" class="headerlink" title="2.7、内存屏障"></a>2.7、内存屏障</h2><p>在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序</p>
<pre><code class="line-numbers language-java">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前
public native void loadFence();
//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前
public native void storeFence();
//内存屏障，禁止load、store操作重排序
public native void fullFence();</code></pre>
<p><strong>典型应用：</strong></p>
<p>在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时；</p>
<h2 id="2-8、系统相关"><a href="#2-8、系统相关" class="headerlink" title="2.8、系统相关"></a>2.8、系统相关</h2><p>这部分包含两个获取系统相关信息的方法。</p>
<pre><code class="line-numbers language-java">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。
public native int addressSize();  
//内存页的大小，此值为2的幂次方。
public native int pageSize();</code></pre>
<p>为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑</p>
<pre><code class="line-numbers language-java">private static int pageSize = -1;
static int pageSize() &#123;
    if (pageSize == -1)
        pageSize = unsafe().pageSize();
    return pageSize;
&#125;
static int pageCount(long size) &#123;
    return (int)(size + (long)pageSize() - 1L) / pageSize();
&#125;</code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类Unsafe</a></li>
</ul>
]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot多环境配置文件</title>
    <url>/2025/02/09/SpringBoot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="1、SpringBoot多环境配置文件"><a href="#1、SpringBoot多环境配置文件" class="headerlink" title="1、SpringBoot多环境配置文件"></a>1、SpringBoot多环境配置文件</h2><p>日常开发工作中，开发和生产环境是隔离的，那么对应的各种配置数据也是不一样的，SpringBoot提供了不同环境的配置数据管理，比如当前目录结构下有两套配置文件，如图：</p>
<p><img src="/images/SpringBoot-profile%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"></p>
<p>在开发环境我们可以使用 <code>application-dev.properties</code>，而部署到正式环境中时，可以指定 <code>application-prod.properties</code></p>
<p>如何指定对应的配置文件？有以下几种方式</p>
<h2 id="2、激活指定的profile"><a href="#2、激活指定的profile" class="headerlink" title="2、激活指定的profile"></a>2、激活指定的profile</h2><ul>
<li><p>在配置文件<code>application.properties</code>中指定：<code>spring.profiles.active=dev</code></p>
</li>
<li><p>命令行：<code>java -jar springboot-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev;</code> 可以直接在测试的时候，配置传入命令行参数</p>
</li>
<li><p>虚拟机参数：<code>-Dspring.profiles.active=dev</code></p>
</li>
</ul>
<h2 id="3、Maven构建指定profile"><a href="#3、Maven构建指定profile" class="headerlink" title="3、Maven构建指定profile"></a>3、Maven构建指定profile</h2><p>上述步骤2中激活指定的profile，但是最终的文件中都包含了所有properties文件，target目录结构如下：</p>
<p><img src="/images/SpringBoot-profile%E7%BC%96%E8%AF%91%E5%90%8E.png"></p>
<p>但是如果编译后的jar包不包含非当前环境需要的properties文件，可以通过maven的的方式来构建，详细步骤如下：</p>
<p><strong>（1）application.properties改为如下代码：</strong></p>
<pre><code>spring.profiles.active=@build.profile.id@</code></pre>
<p><strong>（2）pom.xml增加如下代码：</strong></p>
<pre><code class="line-numbers language-xml">&lt;project&gt;
    ...
      &lt;build&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;filtering&gt;true&lt;/filtering&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;application-*.properties&lt;/exclude&gt;
                &lt;/excludes&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;filtering&gt;false&lt;/filtering&gt;
                &lt;includes&gt;
                    &lt;include&gt;application-$&#123;build.profile.id&#125;.properties&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
    &lt;profiles&gt;
        &lt;!--开发环境--&gt;
        &lt;profile&gt;
            &lt;id&gt;dev&lt;/id&gt;
            &lt;properties&gt;
                &lt;build.profile.id&gt;dev&lt;/build.profile.id&gt;
            &lt;/properties&gt;
            &lt;activation&gt;
                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
            &lt;/activation&gt;
        &lt;/profile&gt;
        &lt;!--生产环境--&gt;
        &lt;profile&gt;
            &lt;id&gt;prod&lt;/id&gt;
            &lt;properties&gt;
                &lt;build.profile.id&gt;prod&lt;/build.profile.id&gt;
            &lt;/properties&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
&lt;/project&gt;</code></pre>
<p><strong>（3）通过如下maven命令执行：</strong></p>
<p>通过IDEA中执行如下操作：</p>
<ul>
<li><p>在idea的maven窗口的lifecycle，在clean上右键弹出如下界面</p>
<p><img src="/images/SpringBoot-profile%E5%88%9B%E5%BB%BAMaven%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4.png"></p>
</li>
<li><p>选择：<code>Create Run/Debug Configuration</code>，弹出如下界面，并在 Command Line 中输入：<code>clean install -DskipTests -P prod -f pom.xml</code></p>
<p><img src="/images/SpringBoot-profile%E5%91%BD%E4%BB%A4%E8%BE%93%E5%85%A5.png"></p>
</li>
<li><p>确认后，在maven的窗口中新增配置：</p>
<p><img src="/images/SpringBoot-profile%E6%9C%80%E7%BB%88%E9%85%8D%E7%BD%AE%E6%98%BE%E7%A4%BA.png"></p>
</li>
<li><p>然后双击执行该命令，执行命令之后打开target目录，可以看到只包含了 <code>application-prod.properties</code> 文件，多余的文件没有包含在里面；</p>
<p><img src="/images/SpringBoot-profile%E7%BC%96%E8%AF%91%E5%90%8E-2.png"></p>
</li>
</ul>
<p>上述操作比较麻烦，可以直接通过命令：<code>mvn clean install -DskipTests -P prod</code>，效果同上面</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger生成带目录的PDF</title>
    <url>/2025/02/09/Swagger%E7%94%9F%E6%88%90%E5%B8%A6%E7%9B%AE%E5%BD%95PDF/</url>
    <content><![CDATA[<h2 id="1、集成Swagger"><a href="#1、集成Swagger" class="headerlink" title="1、集成Swagger"></a>1、集成Swagger</h2><p>集成Swagger详细参考：<a href="https://github.com/chenlanqing/Java-Programmer/blob/main/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/API%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86.md#1%E9%9B%86%E6%88%90swagger-ui">SpringBoot-Swagger</a></p>
<h2 id="2、生成PDF"><a href="#2、生成PDF" class="headerlink" title="2、生成PDF"></a>2、生成PDF</h2><p>主要步骤：</p>
<ul>
<li>通过<a href="https://github.com/Swagger2Markup/swagger2markup">swagger2markup</a>由swagger.json 生成ASCIIDOC；</li>
<li>通过<a href="https://docs.asciidoctor.org/maven-tools/latest/">asciidoctor-maven-plugin</a>生成PDF或Html</li>
</ul>
<h3 id="2-1、生成ASCIIDOC"><a href="#2-1、生成ASCIIDOC" class="headerlink" title="2.1、生成ASCIIDOC"></a>2.1、生成ASCIIDOC</h3><p><a href="https://asciidoc.org/">ASCIIDOC</a> 是一种轻型标记语言，类似于 Markdown；</p>
<p>swagger2markup 提供了两种方式可以将swagger.json文件生成：</p>
<ul>
<li>API</li>
<li>Maven插件</li>
</ul>
<p>获取swagger.json的方式，下图中是获取 v3 版本的数据，也可以获取 v2 版本的数据：<a href="http://localhost:8080/v2/api-docs">http://localhost:8080/v2/api-docs</a></p>
<p><img src="/images/Swagger-API%E5%9C%B0%E5%9D%80.png"></p>
<h4 id="1、swagger2markup-API-生成"><a href="#1、swagger2markup-API-生成" class="headerlink" title="1、swagger2markup API 生成"></a>1、swagger2markup API 生成</h4><p>添加依赖：</p>
<pre><code class="line-numbers language-xm">&lt;dependency&gt;
    &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt;
    &lt;artifactId&gt;swagger2markup&lt;/artifactId&gt;
    &lt;version&gt;1.3.3&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>代码如下：</p>
<pre><code class="line-numbers language-java">public static void main(String[] args) throws Exception &#123;
    // 用于转换的swagger.json可以来自于本地文件，也可以来http 获取
    URL remoteSwaggerFile = new URL(&quot;http://localhost:8080/v2/api-docs&quot;);

    // asciidoc 输出文件夹
    Path outputDir = Paths.get(&quot;./doc/asciidoc/generated&quot;);

    // 转换配置设置
    Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()
            .withMarkupLanguage(MarkupLanguage.ASCIIDOC) // ASCIIDOC
            .withOutputLanguage(Language.ZH) // 中文
            .withPathsGroupedBy(GroupBy.TAGS) // 分组标识
            .build();

    Swagger2MarkupConverter.from(remoteSwaggerFile)
            .withConfig(config)
            .build()
            .toFolder(outputDir);
&#125;</code></pre>
<p>完整属性列表参考官方文档：<a href="https://swagger2markup.github.io/swagger2markup/1.3.3/#_swagger2markup_properties">3.2.5. Swagger2Markup properties</a></p>
<h3 id="1-2、swagger2markup-插件生成"><a href="#1-2、swagger2markup-插件生成" class="headerlink" title="1.2、swagger2markup 插件生成"></a>1.2、swagger2markup 插件生成</h3><p>pom.xml 添加插件如下:</p>
<pre><code class="line-numbers language-xml">&lt;plugin&gt;
    &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt;
    &lt;artifactId&gt;swagger2markup-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.3.3&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt;
            &lt;artifactId&gt;swagger2markup&lt;/artifactId&gt;
            &lt;version&gt;1.3.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;configuration&gt;
        &lt;!--本地 swagger.json 路径 或 远程访问地址--&gt;
        &lt;swaggerInput&gt;http://localhost:8080/v2/api-docs&lt;/swaggerInput&gt;
        &lt;!-- 输出目录 --&gt;
        &lt;outputDir&gt;../doc/asciidoc/generated&lt;/outputDir&gt;
        &lt;config&gt;
            &lt;!--设置输出文件的语言：ASCIIDOC, MARKDOWN, CONFLUENCE_MARKUP--&gt;
            &lt;swagger2markup.markupLanguage&gt;ASCIIDOC&lt;/swagger2markup.markupLanguage&gt;
            &lt;!--设置目录的展现方式--&gt;
            &lt;swagger2markup.pathsGroupedBy&gt;TAGS&lt;/swagger2markup.pathsGroupedBy&gt;
        &lt;/config&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;!--  --&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;convertSwagger2markup&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
<p>生成的时间，修改此处即可：<code>&lt;phase&gt;package&lt;/phase&gt;</code></p>
<h3 id="1-3、生成的目录如下："><a href="#1-3、生成的目录如下：" class="headerlink" title="1.3、生成的目录如下："></a>1.3、生成的目录如下：</h3><p><img src="/images/AsciiDOC-%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png"></p>
<h2 id="2、ASCIIDOC转PDF"><a href="#2、ASCIIDOC转PDF" class="headerlink" title="2、ASCIIDOC转PDF"></a>2、ASCIIDOC转PDF</h2><p>采用 <a href="https://docs.asciidoctor.org/maven-tools/latest/">asciidoctor-maven-plugin</a> 插件的方式来转化Ascii文档。</p>
<h3 id="2-1、添加中文主题和字体文件夹"><a href="#2-1、添加中文主题和字体文件夹" class="headerlink" title="2.1、添加中文主题和字体文件夹"></a>2.1、添加中文主题和字体文件夹</h3><p>下载字体<a href="https://github.com/chloerei/asciidoctor-pdf-cjk-kai_gen_gothic/releases">（RobotoMono 开头和 KaiGenGothicCN 开头的字体文件）和theme文件（Source code (zip)）</a>。</p>
<p>在项目的文档目录下创建fonts和themes两个目录，把下载的8个字体文件复制到fonts目录下，解压<code>asciidoctor-pdf-cjk-kai_gen_gothic-0.1.0-fonts.zip</code>文件，把<code>data\themes\</code>下的<code>cn-theme.yml</code>复制到themes目录下:</p>
<p><img src="/images/AsciiDOC-%E5%AD%97%E4%BD%93%E5%92%8C%E4%B8%BB%E9%A2%98.png"></p>
<h3 id="2-2、创建index-adoc"><a href="#2-2、创建index-adoc" class="headerlink" title="2.2、创建index.adoc"></a>2.2、创建index.adoc</h3><pre><code class="line-numbers language-adoc">include::asciidoc/generated/overview.adoc[]
include::asciidoc/generated/paths.adoc[]
include::asciidoc/generated/security.adoc[]
include::asciidoc/generated/definitions.adoc[]</code></pre>
<p>此文件主要用于指引插件访问asciidoc文档</p>
<h3 id="2-3、插件配置"><a href="#2-3、插件配置" class="headerlink" title="2.3、插件配置"></a>2.3、插件配置</h3><pre><code class="line-numbers language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
    &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.5.3&lt;/version&gt;

    &lt;!-- Include Asciidoctor PDF for pdf generation --&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
            &lt;artifactId&gt;asciidoctorj-pdf&lt;/artifactId&gt;
            &lt;version&gt;1.5.0-alpha.11&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- Comment this section to use the default jruby artifact provided by the plugin --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jruby&lt;/groupId&gt;
            &lt;artifactId&gt;jruby-complete&lt;/artifactId&gt;
            &lt;version&gt;9.1.8.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- Comment this section to use the default AsciidoctorJ artifact provided by the plugin --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
            &lt;artifactId&gt;asciidoctorj&lt;/artifactId&gt;
            &lt;version&gt;1.5.4&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;!-- Configure generic document generation settings --&gt;
    &lt;configuration&gt;
        &lt;!--默认指向 $&#123;basedir&#125;/src/main/asciidoc--&gt;
        &lt;sourceDirectory&gt;../doc/&lt;/sourceDirectory&gt;
        &lt;!--an override to process a single source file; 默认指向 $&#123;sourceDirectory&#125; 中的所有文件--&gt;
        &lt;sourceDocumentName&gt;index.adoc&lt;/sourceDocumentName&gt;
        &lt;attributes&gt;
            &lt;doctype&gt;book&lt;/doctype&gt;
            &lt;toc&gt;left&lt;/toc&gt;
            &lt;toclevels&gt;3&lt;/toclevels&gt;
            &lt;numbered&gt;&lt;/numbered&gt;
            &lt;hardbreaks&gt;&lt;/hardbreaks&gt;
            &lt;sectlinks&gt;&lt;/sectlinks&gt;
            &lt;sectanchors&gt;&lt;/sectanchors&gt;
        &lt;/attributes&gt;
    &lt;/configuration&gt;
    &lt;!-- Since each execution can only handle one backend, run
            separate executions for each desired output type --&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;output-html&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;process-asciidoc&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;backend&gt;html5&lt;/backend&gt;
                &lt;outputDirectory&gt;../doc/asciidoc/html&lt;/outputDirectory&gt;
                &lt;sourceHighlighter&gt;coderay&lt;/sourceHighlighter&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
        &lt;execution&gt;
            &lt;id&gt;output-pdf&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;process-asciidoc&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;backend&gt;pdf&lt;/backend&gt;
                &lt;outputDirectory&gt;../doc/asciidoc/pdf&lt;/outputDirectory&gt;
                &lt;sourceHighlighter&gt;coderay&lt;/sourceHighlighter&gt;
                &lt;doctype&gt;book&lt;/doctype&gt;
                &lt;attributes&gt;
                    &lt;toc&gt;left&lt;/toc&gt;
                    &lt;toclevels&gt;3&lt;/toclevels&gt;
                    &lt;numbered&gt;&lt;/numbered&gt;
                    &lt;hardbreaks&gt;&lt;/hardbreaks&gt;
                    &lt;sectlinks&gt;&lt;/sectlinks&gt;
                    &lt;sectanchors&gt;&lt;/sectanchors&gt;
                    &lt;pdf-fontsdir&gt;./fonts&lt;/pdf-fontsdir&gt;
                    &lt;pdf-stylesdir&gt;./themes&lt;/pdf-stylesdir&gt;
                    &lt;pdf-style&gt;cn&lt;/pdf-style&gt;
                &lt;/attributes&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
<p>生成的时间，修改此处即可：<code>&lt;phase&gt;package&lt;/phase&gt;</code></p>
<h2 id="3、代码目录"><a href="#3、代码目录" class="headerlink" title="3、代码目录"></a>3、代码目录</h2><p>详细代码可以参考：<a href="https://github.com/chenlanqing/springboot-api-doc/tree/main/swagger-document">swagger-document</a></p>
]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID方案汇总</title>
    <url>/2025/02/09/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    <content><![CDATA[<h2 id="1、ID生成的核心需求"><a href="#1、ID生成的核心需求" class="headerlink" title="1、ID生成的核心需求"></a>1、ID生成的核心需求</h2><ul>
<li><p>（1）全局唯一：需要单独设置一个和业务无关的主键；专业术语叫做代理主键这也是为什么数据库设计范式；唯一主键是第一范式!</p>
</li>
<li><p>（2）趋势有序：</p>
<p>  InnoDB引擎表是基于B+树的索引组织表(IOT)；每个表都需要有一个聚集索引；所有的行记录都存储在B+树的叶子节点（leaf pages of the tree）基于聚集索引的增、删、改、查的效率相对是最高的</p>
<ul>
<li>如果我们定义了主键(PRIMARY KEY)；那么InnoDB会选择其作为聚集索引;</li>
<li>如果没有显式定义主键；则InnoDB会选择第一个不包含有 NULL。值的唯一索引作为主键索引</li>
<li>如果也没有这样的唯一索引；则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引（ROWID随着行记录的写入而主键递增；这个ROWID不像ORACLE的ROWID那样可引用；是隐含的）</li>
<li><em>如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话；这时候存取效率是最高的；也就是下面几种情况效率最高：</em><ul>
<li>Ⅰ.使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致</li>
<li>Ⅱ.该表不指定自增列做主键；同时也没有可以被选为主键的唯一索引(上面的条件)；这时候InnoDB会选择内置的ROWID作为主键；写入顺序和ROWID增长顺序一致</li>
<li>Ⅲ.除此以外；如果一个InnoDB表又没有显示主键；又有可以被选择为主键的唯一索引；但该唯一索引可能不是递增关系时（例如字符串、UUID、多字段联合唯一索引的情况）；该表的存取效率就会比较差</li>
</ul>
</li>
</ul>
</li>
<li><p>（3）单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求；</p>
</li>
<li><p>（4）信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则；</p>
</li>
</ul>
<p>上面3、4两点需求是互斥的，无法同时满足3和4点需求；</p>
<p>另外ID生成还需要做到平均延迟和TP延迟都要尽可能低、可用性到5个9、高QPS</p>
<h2 id="2、数据库自增长序列或字段："><a href="#2、数据库自增长序列或字段：" class="headerlink" title="2、数据库自增长序列或字段："></a>2、数据库自增长序列或字段：</h2><p>最常见的方式；利用数据库；全库唯一</p>
<h3 id="2-1、优点"><a href="#2-1、优点" class="headerlink" title="2.1、优点"></a>2.1、优点</h3><ul>
<li>简单；代码方便；性能可以接受;</li>
<li>数字ID天然排序；对分页或者需要排序的结果很有帮助</li>
</ul>
<h3 id="2-2、缺点"><a href="#2-2、缺点" class="headerlink" title="2.2、缺点"></a>2.2、缺点</h3><ul>
<li>不同数据库语法和实现不同；数据库迁移的时候或多数据库版本支持的时候需要处理;</li>
<li>在单个数据库或读写分离或一主多从的情况下；只有一个主库可以生成。有单点故障的风险</li>
<li>在性能达不到要求的情况下；比较难于扩展;</li>
<li>如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦；分表分库的时候会有麻烦</li>
</ul>
<h3 id="2-3、优化方案"><a href="#2-3、优化方案" class="headerlink" title="2.3、优化方案"></a>2.3、优化方案</h3><p>针对主库单点；如果有多个Master库；则每个Master库设置的起始数字不一样；步长一样；可以是Master的个数.</p>
<h2 id="3、UUID"><a href="#3、UUID" class="headerlink" title="3、UUID"></a>3、UUID</h2><h3 id="3-1、优点"><a href="#3-1、优点" class="headerlink" title="3.1、优点"></a>3.1、优点</h3><ul>
<li>简单；代码方便</li>
<li>生成ID性能非常好；基本不会有性能问题。</li>
<li>全球唯一；在遇见数据迁移；系统数据合并；或者数据库变更等情况下；可以从容应对</li>
</ul>
<h3 id="3-2、缺点"><a href="#3-2、缺点" class="headerlink" title="3.2、缺点"></a>3.2、缺点</h3><ul>
<li>没有排序；无法保证趋势递增;</li>
<li>UUID往往是使用字符串存储；查询的效率比较低;</li>
<li>存储空间比较大；如果是海量数据库；就需要考虑存储量的问题;</li>
<li>传输数据量大\不可读；</li>
<li>不可读；</li>
</ul>
<h3 id="3-3、为什么UUID会导致数据库性能变差"><a href="#3-3、为什么UUID会导致数据库性能变差" class="headerlink" title="3.3、为什么UUID会导致数据库性能变差"></a>3.3、为什么UUID会导致数据库性能变差</h3><p>涉及到B+数索引的分裂：果我们的ID按递增的顺序来插入；比如陆续插入8，9，10；新的ID都只会插入到最后一个节点当中。当最后一个节点满了；会裂变出新的节点。这样的插入是性能比较高的插入；因为这样节点的分裂次数最少；而且充分利用了每一个节点的空间。但是；如果我们的插入完全无序；不但会导致一些中间节点产生分裂；也会白白创造出很多不饱和的节点；这样大大降低了数据库插入的性能</p>
<h3 id="3-4、生成有序的UUID"><a href="#3-4、生成有序的UUID" class="headerlink" title="3.4、生成有序的UUID"></a>3.4、生成有序的UUID</h3><p>可以使用<code>fasterxml.uuid</code>来生成有序的UUID，引入POM文件：</p>
<pre><code class="line-numbers language-xml">&lt;!-- 顺序UUID --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.uuid&lt;/groupId&gt;
    &lt;artifactId&gt;java-uuid-generator&lt;/artifactId&gt;
    &lt;version&gt;3.1.4&lt;/version&gt;
&lt;/dependency&gt;     </code></pre>
<p>实现如下：</p>
<pre><code class="line-numbers language-java">public static String generatorUUID()&#123;
    TimeBasedGenerator timeBasedGenerator = Generators.timeBasedGenerator(EthernetAddress.fromInterface());
    return timeBasedGenerator.generate().toString();
&#125;</code></pre>
<h2 id="4、Redis生成ID"><a href="#4、Redis生成ID" class="headerlink" title="4、Redis生成ID"></a>4、Redis生成ID</h2><p>当使用数据库来生成ID性能不够要求的时候；可以尝试使用Redis来生成。主要依赖于Redis是单线程的；所以可以用于生成全局唯一ID。（使用Redis的原子操作incr 和 incrby 来实现）比较适合使用Redis来生成每天从0开始的流水号；</p>
<ul>
<li><p><strong>4.1.优点：</strong></p>
<ul>
<li>不依赖于数据库；灵活方便；且性能优于数据库;</li>
<li>数字ID天然排序；对分页或者需要排序的结果很有帮助;</li>
</ul>
</li>
<li><p><strong>4.2.缺点：</strong></p>
<ul>
<li>如果系统中没有Redis；还需要引入新的组件；增加系统复杂度</li>
<li>需要编码和配置的工作量比较大</li>
</ul>
</li>
</ul>
<h2 id="5、Twitter-Snowflake"><a href="#5、Twitter-Snowflake" class="headerlink" title="5、Twitter-Snowflake"></a>5、Twitter-Snowflake</h2><h3 id="5-1、Snowflake算法组成"><a href="#5-1、Snowflake算法组成" class="headerlink" title="5.1、Snowflake算法组成"></a>5.1、Snowflake算法组成</h3><p>以划分命名空间的方式将 64-bit位分割成多个部分，每个部分代表不同的含义。而 Java中64bit的整数是Long类型，所以在 Java 中 SnowFlake 算法生成的 ID 就是 long 来存储的</p>
<ul>
<li><p>占用1bit；其值始终是0；没有实际作用;为什么？</p>
</li>
<li><p>41位的时间序列(精确到毫秒；41位的长度可以使用69年)</p>
</li>
<li><p>10位的机器标识(其中高位5bit是数据中心ID；低位5bit是工作节点；10位的长度最多支持部署1024个节点)</p>
</li>
<li><p>12位的计数顺序号(12位的计数顺序号支持每个节点每毫秒产生4096个ID序号)。最高位是符号位；始终为0</p>
<p>  算法示意图：</p>
<p>  <img src="/images/snowflake-64bit.jpg"></p>
</li>
</ul>
<p>SnowFlake算法在同一毫秒内最多可以生成全局ID个数：1024 X 4096 =  4194304</p>
<h3 id="5-2、优点"><a href="#5-2、优点" class="headerlink" title="5.2、优点"></a>5.2、优点</h3><ul>
<li>不依赖数据库等第三方系统；以服务的方式部署；稳定性更高；生成ID的性能也是非常高的;</li>
<li>按时间有序；毫秒数在高位；自增序列在低位；整个ID都是趋势递增的</li>
</ul>
<h3 id="5-3、缺点"><a href="#5-3、缺点" class="headerlink" title="5.3、缺点"></a>5.3、缺点</h3><ul>
<li>（1）强依赖机器时钟；如果机器上时钟回拨；会导致发号重复或者服务会处于不可用状态</li>
<li>（2）从理论上来说，类似snowflake的方案由于时间位数的限制，存在于<a href="https://en.wikipedia.org/wiki/Year_2038_problem">2038</a>问题相似的理论极限；</li>
</ul>
<h3 id="5-4、针对缺点解决方案"><a href="#5-4、针对缺点解决方案" class="headerlink" title="5.4、针对缺点解决方案"></a>5.4、针对缺点解决方案</h3><ul>
<li>解决时间问题：可以关闭ntp的时间同步功能；或者当检测到ntp时间调整后；拒绝分配id；</li>
<li>从设计和编码角度来看，一个有效的措施是缓存历史时间戳，然后再序列生成之前校验，如果出现当前时间落后于历史时间的不合理情况，可以采取相应的动作，要么重试、等待时间重新一致，或者直接提示服务不可用。（NTP问题）</li>
</ul>
<h2 id="6、MongoDB的ObjectId"><a href="#6、MongoDB的ObjectId" class="headerlink" title="6、MongoDB的ObjectId"></a>6、MongoDB的ObjectId</h2><p>ObjectId使用12字节的存储空间；其生成方式如下：</p>
<pre><code>|0|1|2|3|4|5|6|7|8|9|10|11|
|时间戳|机器ID|PID|计数器 |</code></pre>
<p>前四个字节时间戳是从标准纪元开始的时间戳；单位为秒；有如下特性：</p>
<ul>
<li>时间戳与后边5个字节一块；保证秒级别的唯一性;</li>
<li>保证插入顺序大致按时间排序</li>
<li>隐含了文档创建时间;</li>
<li>时间戳的实际值并不重要；不需要对服务器之间的时间进行同步<br>时间戳保证秒级唯一；机器ID保证设计时考虑分布式；避免时钟同步；PID保证同一台服务器运行；多个mongod实例时的唯一性；最后的计数器保证同一秒内的唯一性</li>
</ul>
<h2 id="7、Zookeepr"><a href="#7、Zookeepr" class="headerlink" title="7、Zookeepr"></a>7、Zookeepr</h2><p>使用zookeeper分布式锁来实现，zookeeper了解其在高并发情况下的瓶颈；</p>
<p>zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。<br>很少会使用zookeeper来生成唯一ID。主要是由于需要依赖zookeeper，并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁。因此，性能在高并发的分布式环境下，也不甚理想</p>
<h2 id="8、百度uid-generator"><a href="#8、百度uid-generator" class="headerlink" title="8、百度uid-generator"></a>8、百度uid-generator</h2><p><a href="https://github.com/baidu/uid-generator">uid-generator</a></p>
<p>可以解决时钟回拨问题，使用RingBuffer；UidGenerator是Java实现的, 基于Snowflake算法的唯一ID生成器。</p>
<p>依赖版本：Java8及以上版本, MySQL(内置WorkerID分配器, 启动阶段通过DB进行分配; 如自定义实现, 则DB非必选依赖）</p>
<h3 id="8-1、基本原理"><a href="#8-1、基本原理" class="headerlink" title="8.1、基本原理"></a>8.1、基本原理</h3><p>与原始的snowflake算法不同，uid-generator支持自定义时间戳、工作机器id和序列号等各部分的位数，以应用于不同场景。默认分配方式如下。</p>
<ul>
<li><p><code>sign(1bit)</code>：固定1bit符号标识，即生成的UID为正数。</p>
</li>
<li><p><code>delta seconds (28 bits)</code>：当前时间，相对于时间基点”2016-05-20”的增量值，单位：秒，最多可支持约8.7年（注意：1. 这里的单位是秒，而不是毫秒！ </p>
<p>  因为每秒最多生成8192个id，当1秒获取id数多于8192时，RingBuffer中的id很快消耗完毕，在填充RingBuffer时，生成的id的delta seconds 部分只能使用未来的时间</p>
</li>
<li><p><code>worker id (22 bits)</code>：机器id，最多可支持约420w次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。</p>
</li>
<li><p><code>sequence (13 bits)</code>：每秒下的并发序列，13 bits可支持每秒8192个并发。（注意下这个地方，默认支持qps最大为8192个）</p>
</li>
</ul>
<h3 id="8-2、DefaultUidGenerator"><a href="#8-2、DefaultUidGenerator" class="headerlink" title="8.2、DefaultUidGenerator"></a>8.2、DefaultUidGenerator</h3><p>DefaultUidGenerator的产生id的方法与基本上就是常见的snowflake算法实现，仅有一些不同，如以秒为为单位而不是毫秒：</p>
<pre><code class="line-numbers language-java">protected synchronized long nextId() &#123;
    long currentSecond = getCurrentSecond();
    // Clock moved backwards, refuse to generate uid
    if (currentSecond &lt; lastSecond) &#123;
        long refusedSeconds = lastSecond - currentSecond;
        throw new UidGenerateException(&quot;Clock moved backwards. Refusing for %d seconds&quot;, refusedSeconds);
    &#125;
    // At the same second, increase sequence
    if (currentSecond == lastSecond) &#123;
        sequence = (sequence + 1) &amp; bitsAllocator.getMaxSequence();
        // Exceed the max sequence, we wait the next second to generate uid
        if (sequence == 0) &#123;
            currentSecond = getNextSecond(lastSecond);
        &#125;
    // At the different second, sequence restart from zero
    &#125; else &#123;
        sequence = 0L;
    &#125;

    lastSecond = currentSecond;

    // Allocate bits for UID
    return bitsAllocator.allocate(currentSecond - epochSeconds, workerId, sequence);
&#125;</code></pre>
<h3 id="8-3、CachedUidGenerator"><a href="#8-3、CachedUidGenerator" class="headerlink" title="8.3、CachedUidGenerator"></a>8.3、CachedUidGenerator</h3><p>在实现上, UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题。最终单机QPS可达600万；</p>
<p>RingBuffer环形数组，数组每个元素成为一个slot。RingBuffer容量，默认为Snowflake算法中sequence最大值，且为2^N。可通过boostPower配置进行扩容，以提高RingBuffer 读写吞吐量。</p>
<p>Tail指针、Cursor指针用于环形数组上读写slot：</p>
<ul>
<li>Tail指针：表示Producer生产的最大序号(此序号从0开始，持续递增)。Tail不能超过Cursor，即生产者不能覆盖未消费的slot。当Tail已赶上curosr，此时可通过rejectedPutBufferHandler指定PutRejectPolicy；</li>
<li>Cursor指针：表示Consumer消费到的最小序号(序号序列与Producer序列相同)。Cursor不能超过Tail，即不能消费未生产的slot。当Cursor已赶上tail，此时可通过rejectedTakeBufferHandler指定TakeRejectPolicy；</li>
</ul>
<p>使用 RingBuffer 缓存生成的id。RingBuffer是个环形数组，默认大小为8192个，里面缓存着生成的id</p>
<p>获取id：会从ringbuffer中拿一个id，支持并发获取</p>
<p>填充id：RingBuffer填充时机</p>
<ul>
<li>程序启动时，将RingBuffer填充满，缓存着8192个id</li>
<li>在调用getUID()获取id时，检测到RingBuffer中的剩余id个数小于总个数的50%，将RingBuffer填充满，使其缓存8192个id</li>
<li>定时填充（可配置是否使用以及定时任务的周期）；</li>
</ul>
<p>因为delta seconds部分是以秒为单位的，所以1个worker 1秒内最多生成的id书为8192个（2的13次方）</p>
<p>CachedUidGenerator采用了双RingBuffer，Uid-RingBuffer用于存储Uid、Flag-RingBuffer用于存储Uid状态(是否可填充、是否可消费)</p>
<p>由于数组元素在内存中是连续分配的，可最大程度利用CPU cache以提升性能。但同时会带来「伪共享」FalseSharing问题，为此在Tail、Cursor指针、Flag-RingBuffer中采用了CacheLine 补齐方式；</p>
<p>CachedUidGenerator的workerId实现继承自它的父类DefaultUidGenerator，即实例启动时往表WORKER_NODE插入数据后得到的自增ID值</p>
<p><strong>CachedUidGenerator初始化：</strong></p>
<ul>
<li>根据boostPower的值确定RingBuffer的size；</li>
<li>构造RingBuffer，默认paddingFactor为50。这个值的意思是当RingBuffer中剩余可用ID数量少于50%的时候，就会触发一个异步线程往RingBuffer中填充新的唯一ID（调用BufferPaddingExecutor中的paddingBuffer()方法，这个线程中会有一个标志位running控制并发问题），直到填满为止；</li>
<li>判断是否配置了属性scheduleInterval，这是另外一种RingBuffer填充机制，在Schedule线程中，周期性检查填充。默认：不配置，即不使用Schedule线程。如需使用，请指定Schedule线程时间间隔，单位：秒</li>
<li>初始化Put操作拒绝策略，对应属性rejectedPutBufferHandler。即当RingBuffer已满，无法继续填充时的操作策略。默认无需指定，将丢弃Put操作，仅日志记录。如有特殊需求，请实现RejectedPutBufferHandler接口(支持Lambda表达式)；</li>
<li>初始化Take操作拒绝策，对应属性rejectedTakeBufferHandler。即当环已空，无法继续获取时的操作策略。默认无需指定，将记录日志，并抛出UidGenerateException异常。如有特殊需求，请实现RejectedTakeBufferHandler接口；</li>
<li>初始化填满RingBuffer中所有slot（即塞满唯一ID，这一步和第2步骤一样都是调用BufferPaddingExecutor中的paddingBuffer()方法）；</li>
<li>开启buffer补丁线程（前提是配置了属性scheduleInterval），原理就是利用ScheduledExecutorService的scheduleWithFixedDelay()方法</li>
</ul>
<p><strong>说明：</strong>第二步的异步线程实现非常重要，也是UidGenerator解决时钟回拨的关键：在满足填充新的唯一ID条件时，通过时间值递增得到新的时间值（lastSecond.incrementAndGet()），而不是System.currentTimeMillis()这种方式，而lastSecond是AtomicLong类型，所以能保证线程安全问题；</p>
<p><strong>取值：</strong></p>
<p>RingBuffer初始化有值后，接下来就是取值了。不过，由于分布式ID都保存在RingBuffer中，取值过程中就会有一些逻辑判断：</p>
<ul>
<li>如果剩余可用ID百分比低于paddingFactor参数指定值，就会异步生成若干个ID集合，直到将RingBuffer填满；</li>
<li>如果获取值的位置追上了tail指针，就会执行Task操作的拒绝策略；</li>
<li>获取slot中的分布式ID；</li>
<li>将这个slot的标志位只为CANPUTFLAG；</li>
</ul>
<h3 id="8-4、总结"><a href="#8-4、总结" class="headerlink" title="8.4、总结"></a>8.4、总结</h3><p>CachedUidGenerator方式主要通过采取如下一些措施和方案规避了时钟回拨问题和增强唯一性：</p>
<ul>
<li>自增列：UidGenerator的workerId在实例每次重启时初始化，且就是数据库的自增ID，从而完美的实现每个实例获取到的workerId不会有任何冲突。</li>
<li>RingBuffer：UidGenerator不再在每次取ID时都实时计算分布式ID，而是利用RingBuffer数据结构预先生成若干个分布式ID并保存。</li>
<li>时间递增：传统的雪花算法实现都是通过<code>System.currentTimeMillis()</code>来获取时间并与上一次时间进行比较，这样的实现严重依赖服务器的时间。而UidGenerator的时间类型是AtomicLong，且通过incrementAndGet()方法获取下一次的时间，从而脱离了对服务器时间的依赖，也就不会有时钟回拨的问题（这种做法也有一个小问题，即分布式ID中的时间信息可能并不是这个ID真正产生的时间点，例如：获取的某分布式ID的值为3200169789968523265，它的反解析结果为{“timestamp”:”2019-05-02 23:26:39”,”workerId”:”21”,”sequence”:”1”}，但是这个ID可能并不是在”2019-05-02 23:26:39”这个时间产生的）；</li>
</ul>
<h2 id="9、滴滴Tinyid"><a href="#9、滴滴Tinyid" class="headerlink" title="9、滴滴Tinyid"></a>9、滴滴Tinyid</h2><p><a href="https://github.com/didi/tinyid">Tinyid</a>是一个ID生成器服务，它提供了REST API和Java客户端两种获取方式</p>
<h3 id="9-1、使用"><a href="#9-1、使用" class="headerlink" title="9.1、使用"></a>9.1、使用</h3><p><strong>单独部署应用：</strong></p>
<p>从github上下载Tinyid源代码，执行sql文件，tinyid依赖的sql脚本：<code>tinyid/tinyid-server/db.sql</code>，修改相应的配置，启动项目；</p>
<p>通过REST API获取分布式唯一ID，请求实例如下，bizType和token的值请参考tiny_id_token表，获取唯一ID：<code>http://localhost:9999/tinyid/id/nextId?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c</code>；</p>
<p><strong>Client集成：</strong></p>
<p>tinyid还支持Client集成模式，只需要引入如下Maven坐标：</p>
<pre><code class="line-numbers language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.xiaoju.uemc.tinyid&lt;/groupId&gt;
    &lt;artifactId&gt;tinyid-client&lt;/artifactId&gt;
    &lt;version&gt;$&#123;tinyid.version&#125;&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>然后在你的classpath路径下创建配置文件<code>tinyid_client.properties</code>，内容如下，这两个参数就是<code>IdGeneratorFactoryClient.java</code>中tinyid服务端请求地址<code>http://&#123;0&#125;/tinyid/id/nextSegmentIdSimple?token=&#123;1&#125;&amp;bizType=</code>的第一个和第二个参数：</p>
<pre><code>tinyid.server=localhost:9999
tinyid.token=0f673adf80504e2eaa552f5d791b644c</code></pre>
<p><code>tinyid.server</code>还支持多个地址配置，多个地址之间以英文逗号隔开，例如：<code>tinyid.server=host1:9999,tinyid.server=host2:9999</code>；</p>
<p>通过调用tinyid封装的API获取分布式ID，实例代码如下，test就是bizType的值：</p>
<pre><code class="line-numbers language-java">// 单个分布式ID获取
Long id = TinyId.nextId(&quot;test&quot;);
// 多个分布式ID批量获取
List&lt;Long&gt; ids = TinyId.nextId(&quot;test&quot;, 10);</code></pre>
<p>通过配置可知，<code>tinyid-client</code>本质上还是依赖<code>tinyid-server</code>，只不过它封装了对<code>tinyid-server</code>的HTTP请求，然后暴露最简单的API给用户使用而已。它对<code>tinyid-server</code>的HTTP请求封装在<code>TinyIdHttpUtils.java</code>中，依赖JDK原生的<code>HttpURLConnection</code></p>
<h3 id="9-2、原理"><a href="#9-2、原理" class="headerlink" title="9.2、原理"></a>9.2、原理</h3><p>Tinyid的原理非常简单，通过数据库表中的数据基本是就能猜出个八九不离十，就是经典的segment模式；以同一个bizType为例，每个<code>tinyid-server</code>会分配到不同的segment，例如第一个<code>tinyid-server</code>分配到<code>(1000, 2000]</code>，第二个<code>tinyid-server</code>分配到<code>(2000, 3000]</code>，第3个<code>tinyid-server</code>分配到<code>(3000, 4000]</code>：</p>
<p><img src="/images/TinyId%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>
<p>以第一个<code>tinyid-server</code>为例，当它的segment用了20%（核心源码：<code>segmentId.setLoadingId(segmentId.getCurrentId().get() + idInfo.getStep() * Constants.LOADING_PERCENT / 100);</code>，<code>LOADING_PERCENT</code>的值就是20），即设定<code>loadingId</code>为20%的阈值，例如当前id是10000，步长为10000，那么<code>loadingId=12000</code>。那么当请求分布式ID分配到12001时（或者重启后），即超过loadingId，就会返回一个特殊code：<code>new Result(ResultCode.LOADING, id);</code>tinyid-server根据<code>ResultCode.LOADING</code>这个响应码就会异步分配下一个<code>segment(4000, 5000]</code>，以此类推</p>
<h2 id="10、其他方案"><a href="#10、其他方案" class="headerlink" title="10、其他方案"></a>10、其他方案</h2><ul>
<li>使用带业务含义的ID+UUID拼接来生成；</li>
<li><a href="https://github.com/Meituan-Dianping/Leaf">美团Leaf方案</a></li>
</ul>
<h2 id="11、分布式唯一ID需要满足的条件"><a href="#11、分布式唯一ID需要满足的条件" class="headerlink" title="11、分布式唯一ID需要满足的条件"></a>11、分布式唯一ID需要满足的条件</h2><ul>
<li>高可用：不能有单点故障</li>
<li>全局唯一性：不能出现重复的ID号；既然是唯一标识；这是最基本的要求;</li>
<li>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引；在主键的选择上面我们应该尽量使用有序的主键保证写入性能</li>
<li>时间有序：以时间为序；或者ID里包含时间这样一是可以少一个索引；二是冷热数据容易分离;</li>
<li>分片支持：可以控制ShardingId</li>
<li>单调递增：保证下一个ID一定大于上一个ID；例如事务版本号、IM增量消息、排序等特殊需求;</li>
<li>长度适中：不要太长，最好64bit</li>
<li>信息安全：如果ID是连续的；恶意用户的扒取工作就非常容易做了；直接按照顺序下载指定URL即可;    </li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/cqIK5Bv1U0mT97C7EOxmnA">分布式唯一ID</a></li>
<li><a href="https://github.com/baidu/uid-generator">百度分布式ID生成器</a></li>
<li><a href="https://tech.meituan.com/MT_Leaf.html">美团点评分布式ID生成系统</a></li>
<li><a href="https://juejin.im/post/5d22972f6fb9a07edd2a34cc">分布式ID生成方案</a></li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>雪花算法</tag>
      </tags>
  </entry>
</search>
